<!--
 FileName:      compiler
 Author:        8ucchiman
 CreatedDate:   2023-05-19 17:16:21
 LastModified:  2023-01-25 10:56:12 +0900
 Reference:     https://www.sigbus.info/compilerbook
 Description:   ---
-->


- 1. はじめに
    - 1.1 本書の表記法
    - 1.2 本書の想定する開発環境
    - 1.3 著書について
- 2. 機械語とアセンブラ
    - 2.1 CPUとメモリ
    - 2.2 アセンブラとは
    - 2.3 Cとそれに対応するアセンブラ
        - 2.3.1 簡単な例
        - 2.3.2 関数呼び出しを含む例
    - 2.4 本書のまとめ
- 3. 電卓レベルの言語の作成
    - 3.1 ステップ1: 整数1個をコンパイルする言語の作成
    - 3.2 ステップ2: 加減算のできるコンパイラの作成
    - 3.3 ステップ3: トークナイザを導入
    - 3.4 ステップ4: エラーメッセージを改良
    - 3.5 文法の記述方法と再帰下降構文解析
        - 3.5.1 木構造による文法構造の表現
        - 3.5.2 生成規則による文法の定義
        - 3.5.3 BNFによる生成規則の記述
        - 3.5.4 単純な生成規則
        - 3.5.5 生成規則による演算子の優先順位の表現
        - 3.5.6 再帰を含む生成規則
        - 3.5.7 再帰下降構文解析
    - 3.6 スタックマシン
        - 3.6.1 スタックマシンの概念
        - 3.6.2 スタックマシンへのコンパイル
        - 3.6.3 x86-64におけるスタックマシンの実現方法
    - 3.7 ステップ5：四則演算のできる言語の作成
    - 3.8 ステップ6：単項プラスと単項マイナス
    - 3.9 ステップ7: 比較演算子
        - 3.9.1 トークナイザの変更
        - 3.9.2 新しい文法
        - 3.9.3 アセンブリコードの生成
- 4. 分割コンパイルとリンク
    - 4.1 分割コンパイルとは
        - 4.1.1 分割コンパイルとその必要性
        - 4.1.2 ヘッダファイルの必要性とその内容
        - 4.1.3 リンクエラー
        - 4.1.4 グローバル変数の宣言と定義
    - 4.2 C標準ライブラリとアーカイブファイル
    - 4.3 ステップ8: ファイル分割とMakefileの変更
        - 4.3.1 ファイルの分割
        - 4.3.2 Makefileの変更
- 5. 関数とローカル変数
    - 5.1 ステップ9：1文字のローカル変数
        - 5.1.1 スタック上の変数領域
        - 5.1.2 トークナイザの変更
        - 5.1.3 パーサの変更
        - 5.1.4 左辺値と右辺値
        - 5.1.5 任意のアドレスから値をロードする方法
        - 5.1.6 コードジェネレータの変更
        - 5.1.7 メイン関数の変更
    - 5.2 ステップ10：複数文字のローカル変数
    - 5.3 ステップ11：return文
    - 5.4 1973年のCコンパイラ
    - 5.5 ステップ12: 制御構文を足す
    - 5.6 ステップ13: ブロック
    - 5.7 ステップ14: 関数の呼び出しに対応する
    - 5.8 ステップ15: 関数の定義に対応する
    - 5.9 バイナリレベルのインターフェイス
- 6. コンピュータにおける整数の表現
    - 6.1 符号なし整数
    - 6.2 符号あり整数
    - 6.3 符号拡張
    - 6.4 符号の反転
- 7. ポインタと文字列リテラル
    - 7.1 ステップ16: 単項&と単項*
    - 7.2 ステップ17: 暗黙の変数定義を廃止して、intというキーワードを導入する
    - 7.3 ステップ18: ポインタ型を導入する
        - 7.3.1 ポインタを表す型を定義する
        - 7.3.2 ポインタが指している値に代入する
    - 7.4 ステップ19: ポインタの加算と減算を実装する
    - 7.5 ステップ20: sizeof演算子
    - 7.6 ステップ21: 配列を実装する
        - 7.6.1 配列型を定義する
        - 7.6.2 配列からポインタへの暗黙の型変換を実装する
    - 7.8 ステップ22: 配列の添字を実装する
    - 7.9 ステップ23: グローバル変数を実装する
    - 7.10 ステップ24: 文字型を実装する
    - 7.11 ステップ25: 文字列リテラルを実装する
    - 7.12 ステップ26: 入力をファイルから読む
    - 7.13 ステップ27: 行コメントとブロックコメント
    - 7.14 ステップ28: テストをCで書き直す
- 8. プログラムの実行イメージと初期化式
    - 8.1 実行ファイルの構造
    - 8.2 データセグメントの内容
    - 8.3 初期化式の文法
    - 8.4 グローバル変数の初期化式
    - 8.5 ローカル変数の初期化式
- 9. ステップ29以降: [要加筆]
- 10. スタティックリンクとダイナミックリンク
    - 10.1 スタティックリンク
- 11. Cの型の構文
    - 11.1 型を表す図
    - 11.2 型を表す記法
    - 11.3 Cの型の読み方
        - 11.3.1 ネストしていない型の読み方
        - 11.3.2 ネストしている型の読み方
    - 11.4 練習問題
- 12. おわりに
- 13. 付録1：x86-64命令セット チートシート
    - 13.1 整数レジスタの一覧
    - 13.2 メモリアクセス
    - 13.3 関数呼び出し
    - 13.4 条件分岐
    - 13.5 条件代入
    - 13.6 整数・論理演算
- 14. 付録2：Gitによるバージョン管理
    - 14.1 Gitを使ったワークフロー
    - 14.2 コミットするときの注意点
    - 14.3 Gitの内部構造
- 15. 付録3：Dockerを使った開発環境の作成
    - 15.1 セットアップ手順
    - 15.2 コンテナを使ったビルド
    - 15.3 コンテナに新たなアプリケーションを追加
- 16. 参考資料
- 17. 索引



# コンパイラ設計
静的コンパイラ(大概cコンパイラ)
```
                 +-----------+-----------+----------+
  source code -> | front end | optimizer | back end | -> machine language
                 +-----------+-----------+----------+
```

## front end
- ソースコードをぱーすしてエラー検出
- 入力コードを表す言語固有の抽象構文木(AST, Abstract Syntax Tree)を構築

## optimizer
- 冗長な計算の削除などの変形
- 言語とターゲットから独立


## back end
- コードをターゲットの命令セットに置き換える。
- ターゲットアーキテクチャがサポートする特別な機能をうまく使い良いコードを作る。
- 命令選択、レジスタ確保、命令のスケジュール

## 
